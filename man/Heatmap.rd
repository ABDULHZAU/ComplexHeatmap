\name{Heatmap}
\alias{Heatmap}
\title{
Constructor method for Heatmap class
}
\description{
Constructor method for Heatmap class
}
\usage{
Heatmap(matrix, col, name,
    na_col = "grey",
    color_space = "LAB",
    rect_gp = gpar(col = NA),
    border = NA,
    cell_fun = NULL,
    layer_fun = NULL,
    
    row_title = character(0),
    row_title_side = c("left", "right"),
    row_title_gp = gpar(fontsize = 14),
    row_title_rot = switch(row_title_side[1], "left" = 90, "right" = 270),
    column_title = character(0),
    column_title_side = c("top", "bottom"),
    column_title_gp = gpar(fontsize = 14),
    column_title_rot = 0,
    
    cluster_rows = TRUE,
    clustering_distance_rows = "euclidean",
    clustering_method_rows = "complete",
    row_dend_side = c("left", "right"),
    row_dend_width = unit(10, "mm"),
    show_row_dend = TRUE,
    row_dend_reorder = TRUE,
    row_dend_gp = gpar(),
    cluster_columns = TRUE,
    clustering_distance_columns = "euclidean",
    clustering_method_columns = "complete",
    column_dend_side = c("top", "bottom"),
    column_dend_height = unit(10, "mm"),
    show_column_dend = TRUE,
    column_dend_gp = gpar(),
    column_dend_reorder = TRUE,
    
    row_order = NULL,
    column_order = NULL,
    
    row_labels = rownames(matrix),
    row_names_side = c("right", "left"),
    show_row_names = TRUE,
    row_names_max_width = unit(6, "cm"),
    row_names_gp = gpar(fontsize = 12),
    row_names_rot = 0,
    column_labels = colnames(matrix),
    column_names_side = c("bottom", "top"),
    show_column_names = TRUE,
    column_names_max_height = unit(6, "cm"),
    column_names_gp = gpar(fontsize = 12),
    column_names_rot = 90,
    
    top_annotation = NULL,
    bottom_annotation = NULL,
    left_annotation = NULL,
    right_annotation = NULL,
    
    km = 1,
    split = NULL,
    row_km = km,
    row_split = split,
    column_km = 1,
    column_split = NULL,
    gap = unit(0.5, "mm"),
    row_gap = unit(0.5, "mm"),
    column_gap = unit(0.5, "mm"),
    
    width = unit(1, "npc"),
    heatmap_body_width = NULL,
    height = unit(1, "npc"),
    heatmap_body_height = NULL,
    
    show_heatmap_legend = TRUE,
    heatmap_legend_param = list(title = name),
    
    use_raster = nrow(matrix) > 5000,
    raster_device = c("png", "jpeg", "tiff", "CairoPNG", "CairoJPEG", "CairoTIFF"),
    raster_quality = 2,
    raster_device_param = list(),
    
    post_fun = NULL)
}
\arguments{

  \item{matrix}{a matrix. Either numeric or character. If it is a simple vector, it will be converted to a one-column matrix.}
  \item{col}{a vector of colors if the color mapping is discrete or a color mapping  function if the matrix is continuous numbers (should be generated by \code{\link[circlize]{colorRamp2}}. If the matrix is continuous, the value can also be a vector of colors so that colors will be interpolated. Pass to \code{\link{ColorMapping}}.}
  \item{name}{name of the heatmap. The name is used as the title of the heatmap legend.}
  \item{na_col}{color for \code{NA} values.}
  \item{rect_gp}{graphic parameters for drawing rectangles (for heatmap body).}
  \item{color_space}{the color space in which colors are interpolated. Only used if \code{matrix} is numeric and  \code{col} is a vector of colors. Pass to \code{\link[circlize]{colorRamp2}}.}
  \item{border}{border}
  \item{cell_fun}{self-defined function to add graphics on each cell. Seven parameters will be passed into  this function: \code{i}, \code{j}, \code{x}, \code{y}, \code{width}, \code{height}, \code{fill} which are row index, column index in \code{matrix}, coordinate of the middle points in the heatmap body viewport, the width and height of the cell and the filled color. \code{x}, \code{y}, \code{width} and \code{height} are all \code{\link[grid]{unit}} objects.}
  \item{layer_fun}{layer fun}
  \item{row_title}{title on row.}
  \item{row_title_side}{will the title be put on the left or right of the heatmap?}
  \item{row_title_gp}{graphic parameters for drawing text.}
  \item{row_title_rot}{rotation of row titles. Only 0, 90, 270 are allowed to set.}
  \item{column_title}{title on column.}
  \item{column_title_side}{will the title be put on the top or bottom of the heatmap?}
  \item{column_title_gp}{graphic parameters for drawing text.}
  \item{column_title_rot}{rotation of column titles. Only 0, 90, 270 are allowed to set.}
  \item{cluster_rows}{If the value is a logical, it means whether make cluster on rows. The value can also be a \code{\link[stats]{hclust}} or a \code{\link[stats]{dendrogram}} that already contains clustering information. This means you can use any type of clustering methods and render the \code{\link[stats]{dendrogram}} object with self-defined graphic settings.}
  \item{clustering_distance_rows}{it can be a pre-defined character which is in  ("euclidean", "maximum", "manhattan", "canberra", "binary",  "minkowski", "pearson", "spearman", "kendall"). It can also be a function. If the function has one argument, the input argument should be a matrix and  the returned value should be a \code{\link[stats]{dist}} object. If the function has two arguments, the input arguments are two vectors and the function calculates distance between these two vectors.}
  \item{clustering_method_rows}{method to make cluster, pass to \code{\link[stats]{hclust}}.}
  \item{row_dend_side}{should the row cluster be put on the left or right of the heatmap?}
  \item{row_dend_width}{width of the row cluster, should be a \code{\link[grid]{unit}} object.}
  \item{show_row_dend}{whether show row clusters. }
  \item{row_dend_gp}{graphics parameters for drawing lines. If users already provide a \code{\link[stats]{dendrogram}} object with edges rendered, this argument will be ignored.}
  \item{row_dend_reorder}{apply reordering on rows. The value can be a logical value or a vector which contains weight  which is used to reorder rows}
  \item{cluster_columns}{whether make cluster on columns. Same settings as \code{cluster_rows}.}
  \item{clustering_distance_columns}{same setting as \code{clustering_distance_rows}.}
  \item{clustering_method_columns}{method to make cluster, pass to \code{\link[stats]{hclust}}.}
  \item{column_dend_side}{should the column cluster be put on the top or bottom of the heatmap?}
  \item{column_dend_height}{height of the column cluster, should be a \code{\link[grid]{unit}} object.}
  \item{show_column_dend}{whether show column clusters.}
  \item{column_dend_gp}{graphic parameters for drawling lines. Same settings as \code{row_dend_gp}.}
  \item{column_dend_reorder}{apply reordering on columns. The value can be a logical value or a vector which contains weight  which is used to reorder columns}
  \item{row_order}{order of rows. It makes it easy to adjust row order for a list of heatmaps if this heatmap  is selected as the main heatmap. Manually setting row order should turn off clustering}
  \item{column_order}{order of column. It makes it easy to adjust column order for both matrix and column annotations.}
  \item{row_labels}{row labels}
  \item{row_names_side}{should the row names be put on the left or right of the heatmap?}
  \item{show_row_names}{whether show row names.}
  \item{row_names_max_width}{maximum width of row names viewport. Because some times row names can be very long, it is not reasonable to show them all.}
  \item{row_names_gp}{graphic parameters for drawing text.}
  \item{row_names_rot}{rotation of row labels}
  \item{column_labels}{column labels}
  \item{column_names_side}{should the column names be put on the top or bottom of the heatmap?}
  \item{column_names_max_height}{maximum height of column names viewport.}
  \item{show_column_names}{whether show column names.}
  \item{column_names_gp}{graphic parameters for drawing text.}
  \item{column_names_rot}{rotation of column labels}
  \item{top_annotation}{a \code{\link{HeatmapAnnotation}} object which contains a list of annotations.}
  \item{bottom_annotation}{a \code{\link{HeatmapAnnotation}} object.}
  \item{left_annotation}{should specified in \code{\link{rowAnnotation}}}
  \item{right_annotation}{should shpecified in \code{\link{rowAnnotation}}}
  \item{km}{do k-means clustering on rows. If the value is larger than 1, the heatmap will be split by rows according to the k-means clustering. For each row-clusters, hierarchical clustering is still applied with parameters above.}
  \item{split}{a vector or a data frame by which the rows are split. But if \code{cluster_rows} is a clustering object, \code{split} can be a single number indicating rows are to be split according to the split on the tree.}
  \item{row_km}{row km}
  \item{row_split}{row split}
  \item{column_km}{column km}
  \item{column_split}{column split}
  \item{gap}{gap between row-slices if the heatmap is split by rows, should be \code{\link[grid]{unit}} object. If it is a vector, the order corresponds to top to bottom in the heatmap}
  \item{row_gap}{row gap}
  \item{column_gap}{column gap}
  \item{width}{width}
  \item{height}{height}
  \item{heatmap_body_width}{width}
  \item{heatmap_body_height}{height}
  \item{show_heatmap_legend}{whether show heatmap legend?}
  \item{heatmap_legend_param}{a list contains parameters for the heatmap legend. See \code{\link{color_mapping_legend,ColorMapping-method}} for all available parameters.}
  \item{use_raster}{whether render the heatmap body as a raster image. It helps to reduce file size when the matrix is huge. Note if \code{cell_fun} is set, \code{use_raster} is enforced to be \code{FALSE}.}
  \item{raster_device}{graphic device which is used to generate the raster image}
  \item{raster_quality}{a value set to larger than 1 will improve the quality of the raster image.}
  \item{raster_device_param}{a list of further parameters for the selected graphic device}
  \item{post_fun}{a function which will be executed after the plot is drawn.}

}
\details{
The initialization function only applies parameter checking and fill values to each slot with proper ones.
Then it will be ready for clustering and layout.

Following methods can be applied on the \code{\link{Heatmap-class}} object:

\itemize{
  \item \code{\link{show,Heatmap-method}}: draw a single heatmap with default parameters
  \item \code{\link{draw,Heatmap-method}}: draw a single heatmap.
  \item \code{\link{add_heatmap,Heatmap-method}} append heatmaps and row annotations to a list of heatmaps.
}

The constructor function pretends to be a high-level graphic function because the \code{show} method
of the \code{\link{Heatmap-class}} object actually plots the graphics.
}
\value{
A \code{\link{Heatmap-class}} object.
}
\author{
Zuguang Gu <z.gu@dkfz.de>
}
\examples{
# There is no example
NULL

}
