
#####################################
# class and methods to map values to colors
#

# == title
# Class to map values to colors
#
# == details
# The `ColorMapping-class` handles color mapping with both discrete values and continuous values.
# Discrete values are mapped by setting a vector of colors and continuous values are mapped by setting
# a color mapping function.
#
# == methods
# The `ColorMapping-class` provides following methods:
#
# - `ColorMapping`: contructor methods.
# - `map_to_colors,ColorMapping-method`: mapping values to colors.
# - `color_mapping_legend,ColorMapping-method`: draw legend or get the size of the legend.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
ColorMapping = setClass("ColorMapping",
	slots = list(
		colors  = "character", # a list of colors
		levels  = "character", # levels which colors correspond to
		col_fun = "function", # function to map values to colors
		type    = "character",  # continuous or discrete
		name    = "character",  # used to map to the dataset and taken as the title of the legend
		na_col  = "character",
		color_bar = "character",
		legend_title = "ANY"
	)
)

# == title
# Constructor methods for ColorMapping class
#
# == param
# -name name for this color mapping. It is used for drawing the title of the legend.
# -colors discrete colors.
# -levels levels that correspond to ``colors``. If ``colors`` is name indexed, 
#         ``levels`` can be ignored.
# -col_fun color mapping function that maps continuous values to colors.
# -breaks breaks for the continuous color mapping. If ``col_fun`` is
#         generated by `circlize::colorRamp2`, ``breaks`` can be ignored.
# -enforce_breaks If it is set to `TRUE`, values of ``breaks`` will be the final break value in the legend.
#            If it is ``FALSE``, proper breaks values will be automatically generated.
# -na_col colors for ``NA`` values.
# -legend_title title of the legend, by default it is the name of the legend
# -color_bar if the color mapping is continuous, whether draw the legend discrete or continuous.
#
# == detail
# ``colors`` and ``levels`` are used for discrete color mapping, ``col_fun`` and 
# ``breaks`` are used for continuous color mapping.
#
# == value
# A `ColorMapping-class` object.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
ColorMapping = function(name, colors = NULL, levels = NULL, 
	col_fun = NULL, breaks = NULL, enforce_breaks = FALSE, na_col = "#FFFFFF",
	legend_title = name, color_bar = c("discrete", "continuous")) {

	.Object = new("ColorMapping")

	if(missing(name)) {
		increase_color_mapping_index()
		name = get_color_mapping_index()
	}
	if(!is.null(colors)) {
		if(is.null(levels)) {
			if(is.null(names(colors))) {
				stop("either provide `levels` or provide named `colors`.\n")
			}
			levels = names(colors)
		}
		if(length(colors) != length(levels)) {
			stop("length of colors and length of levels should be the same.\n")
		}
		.Object@colors = colors
		if(is.numeric(levels)) {
			.Object@levels = as.character(levels)
			#attr(.Object@levels, "numeric") = TRUE
		} else {
			.Object@levels = levels
		}
		names(.Object@colors) = levels
		.Object@type = "discrete"
	} else if(!is.null(col_fun)) {
		if(is.null(breaks)) {
			breaks = attr(col_fun, "breaks")
			if(is.null(breaks)) {
				stop("You should provide breaks.\n")
			}
		}
		if(enforce_breaks) {
			le = breaks
		} else {
			le1 = grid.pretty(range(breaks))
			le2 = pretty(breaks, n = 3)
			if(abs(length(le1) - 5) < abs(length(le2) - 5)) {
				le = le1
			} else {
				le = le2
			}
		}
		.Object@colors = col_fun(le)
		.Object@levels = as.character(le)
		.Object@col_fun = col_fun
		.Object@type = "continuous"
	} else {
		stop("initialization failed. Either specify `colors` + `levels` or `col_fun` + `breaks`\n")
	}

	.Object@name = name
	.Object@na_col = na_col

	.Object@legend_title = legend_title
	color_bar = match.arg(color_bar)[1]
	if(.Object@type == "discrete" && color_bar == "continuous") {
		stop("Continuous color bar can only be applied to continuous color mapping.")
	}
	.Object@color_bar = color_bar

	return(.Object)
}

# == title
# Print ColorMapping object
#
# == param
# -object a `ColorMapping-class` object.
#
# == value
# This function returns no value.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
setMethod(f = "show",
	signature = "ColorMapping",
	definition = function(object) {
	if(object@type == "discrete") {
		cat("Discrete color mapping:\n")
		cat("name:", object@name, "\n")
		cat("levels:\n")
		print(object@levels)
		cat("\n")
		cat("colors:\n")
		col = object@colors; names(col) = NULL
		print(col)
		cat("\n")
	} else if(object@type == "continuous") {
		cat("Continuous color mapping:\n")
		cat("name:", object@name, "\n")
		cat("breaks:\n")
		print(object@levels)
		cat("\n")
		cat("colors:\n")
		col = object@colors; names(col) = NULL
		print(col)
		cat("\n")
	}
})

# == title
# Map values to colors
#
# == param
# -object a `ColorMapping-class` object.
# -x input values.
#
# == details
# It maps a vector of values to a vector of colors.
#
# == value
# A vector of colors.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
setMethod(f = "map_to_colors",
	signature = "ColorMapping",
	definition = function(object, x) {
	
	if(is.factor(x)) x = as.vector(x)
	original_attr = attributes(x)
	x2 = vector(length = length(x))

	if(object@type == "discrete") {
		lna = is.na(x)

		if(is.numeric(x)) x = as.character(x)
		if(any(! x[!lna] %in% object@levels)) {
			msg = paste0("Cannot map some of the levels:\n", paste(setdiff(x[!lna], object@levels), sep = ", ", collapse = ", "))
			stop(msg)
		}	
		
		x2[lna] = object@na_col
		x2[!lna] = object@colors[ x[!lna] ]
	} else {
		lna = is.na(x)
		x2[lna] = object@na_col
		x2[!lna] = object@col_fun(x[!lna])
	}

	# keep original attributes, such as dimension
	attributes(x2) = original_attr
	return(x2)
})


# == title
# Draw legend based on color mapping
#
# == param
# -object a `ColorMapping-class` object.
# -... pass to `grid::viewport`.
# -plot whether to plot or just return the size of the legend viewport.
# -legend_grid_height height of each legend grid.
# -legend_grid_width width of each legend grid.
# -legend_grid_border color for legend grid borders.
# -legend_title_gp graphic parameter for legend title.
# -legend_label_gp graphic parameter for legend label.
#
# == details
# A viewport is created which contains a legend title, legend grids and corresponding labels.
#
# == value
# A `grid::grob` object which contains the legend
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
setMethod(f = "color_mapping_legend",
	signature = "ColorMapping",
	definition = function(object, ..., plot = TRUE, legend_grid_height = unit(4, "mm"),
	legend_grid_width = unit(4, "mm"), legend_grid_border = "white",
	legend_title_gp = gpar(fontsize = 10, fontface = "bold"),
	legend_label_gp = gpar(fontsize = 10)) {

	legend_title_gp = check_gp(legend_title_gp)
	legend_label_gp = check_gp(legend_label_gp)

	color_bar = object@color_bar

	# add title
	legend_title_grob = textGrob(object@legend_title, just = c("left", "top"), gp = legend_title_gp)
	legend_title_height = grobHeight(legend_title_grob)
	legend_title_width = grobWidth(legend_title_grob)

	grid_padding = unit(1, "mm") # padding to the legend labels
	legend_padding = unit(1.5, "mm")
	nlevel = length(object@levels)
	legend_label_max_width = max(do.call("unit.c", lapply(object@levels, function(x) {
			grobWidth(textGrob(x, gp = legend_label_gp))
		})))

	legend_label_max_width = max(unit.c(legend_label_max_width + grid_padding + legend_grid_width, legend_title_width)) - legend_grid_width - grid_padding
	
	gf = frameGrob(layout = grid.layout(nr = 2, nc = 2, width = unit.c(legend_grid_width, grid_padding + legend_label_max_width),
		                                                height = unit.c(legend_title_height, legend_padding + nlevel*(legend_grid_height))))
	# legend title
	gf = packGrob(gf, row = 1, col = 1:2, grob = textGrob(object@legend_title, x = 0, y = 1, default.units = "npc", just = c("left", "top"), gp = legend_title_gp))
	
	# legend grid
	x = unit(rep(0, nlevel), "npc")
	y = legend_padding + (0:(nlevel-1))*(legend_grid_height)
	y = unit(1, "npc") - y
	if(color_bar == "discrete") {
		gf = packGrob(gf, row = 2, col = 1, grob = rectGrob(x, rev(y), width = legend_grid_width, height = rev(legend_grid_height), just = c("left", "top"),
				gp = gpar(col = legend_grid_border, fill = object@colors)))
	} else {
		colors = unlist(lapply(seq_len(nlevel-1), function(i) object@col_fun(seq(as.numeric(object@levels[i]), as.numeric(object@levels[i+1]), length = 20))))
		x2 = unit(rep(0, length(colors)), "npc")
		y2 = seq(0, 1, length = length(colors)) * (unit(1, "npc") - legend_padding - legend_grid_height) + legend_grid_height*0.5
		gf = packGrob(gf, row = 2, col = 1, grob = rectGrob(x2, rev(y2), width = legend_grid_width, height = (unit(1, "npc") - legend_padding)*(1/length(colors)), just = c("left", "top"),
				gp = gpar(col = rev(colors), fill = rev(colors))), height = legend_padding + nlevel*(legend_grid_height), force.height = TRUE)
	}
	gf = packGrob(gf, row = 2, col = 2, grob = textGrob(object@levels, x + grid_padding, rev(y) - legend_grid_height*0.5, 
	 		just = c("left", "center"), gp = legend_label_gp), width = grid_padding + legend_label_max_width, force.width = TRUE)

	if(plot) {
		pushViewport(viewport(..., width = grobWidth(gf), height = grobHeight(gf), name = paste0("legend_", object@name)))
		grid.draw(gf)
		upViewport()
	}

	#size = unit.c(vp_width, vp_height)
	return(invisible(gf))
})
