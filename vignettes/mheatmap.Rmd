<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Making Complex Heatmaps}
-->

Making Complex Heatmaps
========================================

**Author**: Zuguang Gu ( z.gu@dkfz.de )

**Date**: `r Sys.Date()`

-------------------------------------------------------------

```{r, echo = FALSE, message = FALSE}
library(markdown)
options(markdown.HTML.options = c(options('markdown.HTML.options')[[1]], "toc"))

library(knitr)
knitr::opts_chunk$set(
    error = FALSE,
    tidy  = FALSE,
    message = FALSE,
    fig.align = "center",
    fig.width = 5,
    fig.height = 5)
options(markdown.HTML.stylesheet = "custom.css")

options(width = 100)
```

Complex heatmaps are efficient to visualize associations 
between different sources of data sets and reveal potential features. 
Here the **mheatmap** package provides a highly flexible way to arrange 
multiple heatmaps and supports self-defined annotation graphics.

## General design

Generally, a heatmap list contains several heatmaps and row annotations.

```{r, echo = FALSE, fig.width = 10, fig.height = 5}
source("design.R")
```

There are several classes that are abstracted from the heatmap. Surounding the heatmap list,
there are legends for heatmaps themselves and annotations, also there are titles which are placed
on the four sides of the heatmap list. For each heatmap, there are also different components stand
surrounding the heatmap body.

In **mheatmap** package, components of heatmap lists are abstracted into several classes.

- `Heatmap` class: A single heatmap containing heatmap body, row/column names, titles and dendrograms.
- `HeatmapList` class: A list of heatmaps and row annotations which also contains titles.
- `HeatmapAnnotation` class: be respossible to row annotations and column annotations.

There are also several internal classes:

- `Single Annotation` class: a single row annotation or column annotation.
- `ColorMapping` class: mapping from values to colors.

**mheatmap** is implemeted under **grid** system, so users should know basic **grid** functionality
to get full use of **mheatmap** package.

## A single heatmap

A single heatmap is mosted used for a quick view of the data. It is a special case of 
a heatmap list which only contains one heatmap. In following examples, we will demonstrate
how to set parameters for visualization a single heatmap.

First let's load packages and generate a random matrix:

```{r}
library(mheatmap)
library(circlize)
library(colorspace)
library(GetoptLong)

set.seed(123)

mat = matrix(rnorm(80, 2), 8, 10)
mat = rbind(mat, matrix(rnorm(40, -2), 4, 10))
rownames(mat) = paste0("R", 1:12)
colnames(mat) = paste0("C", 1:10)
```

Plot the heatmap with default settings. The default style of the heatmap is quite the same
as that generated by other similar heatmap functions.

```{r}
Heatmap(mat)
```

### Colors

In most cases, the heatmap visualizes a matrix with continuous values that are mapped.
In this case, user should provide a color mapping function. A color mapping function
should accept a vector of values and return a vector of corresponding colors. The `colorRamp2()` from
the **circlize** package is helpful for generating such functions. The two arguments for `colorRamp2()`
is a vector of breaks values and corresponding colors.

```{r}
Heatmap(mat, col = colorRamp2(c(-3, 0, 3), c("green", "white", "red")))
```

If the matrix contains discrete values (either numeric or character), colors should be specified as
a named vector to make it possible for the mapping from discrete values to colors.

```{r}
discrete_mat = matrix(sample(1:4, 100, replace = TRUE), 10, 10)
colors = structure(rainbow_hcl(4), names = c("1", "2", "3", "4"))
Heatmap(discrete_mat, col = colors)
```

Or a character matrix:

```{r}
discrete_mat = matrix(sample(letters[1:4], 100, replace = TRUE), 10, 10)
colors = structure(rainbow_hcl(4), names = letters[1:4])
Heatmap(discrete_mat, col = colors)
```

As you see, for the numeric matrix, by default clustering is applied on both dimensions while
for character matrix, clustering is suppressed.

### Titles

The name of the heatmap is used as the title of the heatmap legend.
The name also plays as a unique id if you plot more than one heatmaps together (introduced in laster sections).

```{r}
Heatmap(mat, name = "foo")
```

You can set heatmap titles either by the rows or by the columns. Note at a same time
you can only put e.g. column title either on the top or at the bottom of the heatmap.
The graphic paramters can be set by `row_title_gp` and `column_title_gp` respectively.
Please remember you should use `gpar()` to specify graphic parameters.

```{r}
Heatmap(mat, name = "foo", column_title = "I am a column title", 
    row_title = "I am a row title")
Heatmap(mat, name = "foo", column_title = "I am a column title at the bottom", 
    column_title_side = "bottom")
Heatmap(mat, name = "foo", column_title = "I am a big column title", 
    column_title_gp = gpar(fontsize = 20, fontface = "bold"))
```

### Clustering

Clustering may be the key feature of the heatmap visualization. In **mheatmap** package,
clustering is supported with high flexibility. For different levels, you can specify the 
clustering either by a pre-defined method, or by a distance function, or by a object that already
contains clustering, or directly by a clustering function. It is also possible to render 
your dendrograms with different colors and styles for different branches for better revealing
structures of your data.

First there are general settings for the clustering, e.g. whether show dendrograms, side
of the dendrograms and size of the dendrograms.

```{r}
Heatmap(mat, name = "foo", cluster_rows = FALSE)
Heatmap(mat, name = "foo", show_column_hclust = FALSE)
Heatmap(mat, name = "foo", row_hclust_side = "right")
Heatmap(mat, name = "foo", column_hclust_height = unit(2, "cm"))
```

There are three ways to specify distance metric for clustering:

- specify distance as a pre-defined option. The valid values are the supported methods
  in `dist()` function and within `pearson`, `spearman` and `kendall`.
- a self-defined function which calculates distance from a matrix. The function should
  only contain one argument. Please note for clustering on columns, the matrix will be transposed
  automatically.
- a self-defined function which calculates distance from two vectors. The function should
  only contain two arguments.

```{r}
Heatmap(mat, name = "foo", clustering_distance_rows = "pearson")
Heatmap(mat, name = "foo", clustering_distance_rows = function(m) dist(m))
Heatmap(mat, name = "foo", clustering_distance_rows = function(x, y) 1 - cor(x, y))
```

Method to make hierarchical clustering can be specified by `clustering_method_rows` and
`clustering_method_columns`. Possible methods are those supported in `hclust()` function.

```{r}
Heatmap(mat, name = "foo", clustering_method_rows = "single")
```

By default, clustering are performed by `hclust()`. But you can also utilize clustering results
which are generated by other methods by specifying `cluster_rows` or `cluster_columns` to a 
`hclust` or `dendrogram` object. In following examples, we use `diana()` and `agnes()` methods
which are from the **cluster** package to perform clusterings.

```{r}
library(cluster)
Heatmap(mat, name = "foo", cluster_rows = as.dendrogram(diana(mat)),
   cluster_columns = as.dendrogram(agnes(t(mat))))
```

You can render your `dendrogram` object by the **dendextend** package and make a more customized
visualization of the dendrogram. 

```{r}
library(dendextend)
dend = hclust(dist(mat))
dend = color_branches(dend, k = 2)
Heatmap(mat, name = "foo", cluster_rows = dend)
```

More generally, `cluster_rows` and `cluster_columns` can be functions which calculate the clusterings.
The input argument should be a matrix and returned value of the function should be a `hclust` or `dendrogram`
object. Please note, when `cluster_rows` is executed internally, the argument `m` is the input `mat` itself
while `m` is the transpose of `mat` when executing `cluster_columns`.

```{r}
Heatmap(mat, name = "foo", cluster_rows = function(m) hclust(dist(m)),
    cluster_columns = function(m) hclust(dist(m)))
```

### Dimension names

Set row names or column names. Side, visibility and graphics parameter for dimension names can be set.

```{r}
Heatmap(mat, name = "foo", row_names_side = "left", row_hclust_side = "right", 
    column_names_side = "top", column_hclust_side = "bottom")
Heatmap(mat, name = "foo", show_row_names = FALSE)
Heatmap(mat, name = "foo", row_names_gp = gpar(fontsize = 20))
```

### Split heatmap by rows

A heatmap can be splitted by rows. The `km` argument with a value larger than 1 means applying a k-means clustering
on rows.

```{r}
Heatmap(mat, name = "foo", km = 2)
```

More generally, `split` can be set to a vector or a data frame in which different combination of levels
split the rows of the heatmap. Actually, k-means clustering just generate a vector of row classes and append
`split` with one additional column. The combined row titles can be controlled by `combined_name_fun` argument.

```{r}
Heatmap(mat, name = "foo", split = rep(c("A", "B"), 6))
Heatmap(mat, name = "foo", split = data.frame(rep(c("A", "B"), 6), rep(c("C", "D"), each = 6)))
Heatmap(mat, name = "foo", split = data.frame(rep(c("A", "B"), 6), rep(c("C", "D"), each = 6)), 
    combined_name_fun = function(x) paste(x, collapse = "\n"))
Heatmap(mat, name = "foo", km = 2, split = rep(c("A", "B"), 6), 
    combined_name_fun = function(x) paste(x, collapse = "\n"))
Heatmap(mat, name = "foo", km = 2, split = rep(c("A", "B"), 6), combined_name_fun = NULL)
```

If you are not happy with the default k-means partitioning method, it is easy to use other partitioning methods
by just assigning the partitioning vector to `split`.

```{r}
pa = pam(mat, k = 3)
Heatmap(mat, name = "foo", split = paste0("pam", pa$clustering))
```

Height of gaps between every row slices can be controlled by `gap`.

```{r}
Heatmap(mat, name = "foo", split = paste0("pam", pa$clustering), gap = unit(5, "mm"))
```

Character matrix can only be splitted by `split` argument.

```{r}
Heatmap(discrete_mat, name = "foo", split = rep(letters[1:2], 5))
```

### Self define the heatmap body

The heatmap body can also be self-defined. By default the heatmap body is composed by an array of rectangles
with different filled colors. If `type` in `rect_gp` is set to `none`, the array for rectangles is initialized but
no graphics are put in. Then, users can defined their own graphic function by `cell_fun`. `cell_fun` is applied
on every cell in the heatmap and provides following information on the 'current' cell:

- `i`: row index in the matrix.
- `j`: column index in the matrix.
- `x`: x coordinate of middle point of the cell which is measured in the viewport of the heatmap body.
- `y`: u coordinate of middle point of the cell which is measured in the viewport of the heatmap body.
- `width`: width of the cell.
- `height`: height of the cell.
- `fill`: color of the cell.

In following example, we draw round rectangles and add text. We assign the heatmap to a variable
and make the plot explictly by calling `draw()`, just in order to suppress the heatmap legend. 
This functionality will be introduced in later sections.

```{r}
mat2 = matrix(1:9, 3, 3)

ht = Heatmap(mat2, rect_gp = gpar(col = "white", lwd = 2, type = "none"), 
    cell_fun = function(i, j, x, y, width, height, fill) {
        grid.roundrect(x, y, width*0.8, height*0.8, gp = gpar(fill = fill))
        if(mat[i, j] <= 4) {
            grid.text("cold", x = x, y = y)
        } else if(mat[i, j] >= 6) {
            grid.text("hot", x = x, y = y)
        } else {
            grid.text("normal", x = x, y = y)
        }
    },
    cluster_rows = FALSE, cluster_columns = FALSE)
draw(ht, show_heatmap_legend = FALSE)
```

## The HeatmapAnnotation class

In this section, we only describe how to generate a column annotations. Row annotations
will be described in later sections.

The annotation graphics actually are quite general. The only common characteristic for column annotation
is that they are aligned to the columns of the heatmap. Here there is a `HeatmapAnnotation` class which is used to 
define annotations on columns.

### Simple annotation

A simple annotation is defined as a vector which contains discrete classes or continuous values corresponding to the columns.
Since the simple annotation is represented as a vector, multiple simple annotations can be specified
as a data frame. Colors for the simple annotations can be specified by `col` with discrete values or
color mapping functions, depending on whether the simple annotations are discrete or continuous.

When plotting the heatmap, simple annotations will be represented as rows of grids.

There is a `draw()` method for the `HeatmapAnnotation` class. `draw()` is used internally and here
we just use it for illustration.

```{r, fig.width = 7, fig.height = 1}
df = data.frame(type = c(rep("a", 5), rep("b", 5)))
ha = HeatmapAnnotation(df = df)
ha
draw(ha, 1:10)
```

```{r, fig.width = 7, fig.height = 1}
ha = HeatmapAnnotation(df = df, col = list(type = c("a" =  "red", "b" = "blue")))
ha
draw(ha, 1:10)
```

```{r, fig.width = 7, fig.height = 1}
ha = HeatmapAnnotation(df = data.frame(age = sample(1:20, 10)),
    col = list(age = colorRamp2(c(1, 20), c("white", "red"))))
ha
draw(ha, 1:10)
```

### Complex annotations

Besides simple annotations, these are complex annotations. The complex annotations are always
represented as self-defined functions. Actually, for each column annotation, there will be a viewport
created waiting for graphics. The annotation function here defines how to put the graphics to
this viewport. The only argument of the function is an index of column which may be adjusted by column clustering.

In following example, an annotation of points is created. Please note how we define `xscale` so that positions
of points correspond to middle points of the columns.

```{r, fig.width = 7, fig.height = 1}
value = rnorm(10)
column_anno = function(index) {
    n = length(index)
    pushViewport(viewport(xscale = c(0.5, n + 0.5), yscale = range(value)))
    grid.points(index, value, pch = 16)
    upViewport() # this is very important in order not to mess up the layout
}
ha = HeatmapAnnotation(points = column_anno)
ha
draw(ha, 1:10)
```

For simple annotation graphics, you can create such annotation function by `anno_simple()`.
`anno_simple()` will return an annotation function which just satisfy our needs.

```{r, fig.width = 7, fig.height = 1}
ha = HeatmapAnnotation(points = anno_simple(value, type = "p"))
draw(ha, 1:10)
```

```{r, fig.width = 7, fig.height = 1}
ha = HeatmapAnnotation(points = anno_simple(value, type = "histogram"))
draw(ha, 1:10)
```

There is also an `anno_boxplot()` which generates boxplot for each column in the matrix.
Please note here you need to transpose the matrix because `anno_boxplot()` doesn't know
the annotation is on columns or on rows.

```{r, fig.width = 7, fig.height = 1}
ha = HeatmapAnnotation(boxplot = anno_boxplot(t(mat)))
draw(ha, 1:10)
```

You can combine more than one annotations into the object.

```{r, fig.width = 7, fig.height = 2}
ha = HeatmapAnnotation(df = df, points = anno_points(value))
ha
draw(ha, 1:10)
```

If there are more than one annotations, you can control height of each annotation by `annotation_height`.
The value of `annotation_height` can either be numeric values or `unit` objects. But when you specify the 
height to the `unit` objects, you should make sure the sum of heights does not exceed the height of the 
annotations shown in the heatmap.

```{r, fig.width = 7, fig.height = 3}
ha = HeatmapAnnotation(df = df, points = anno_points(value), boxplot = anno_boxplot(t(mat)),
    annotation_height = c(1, 2, 3))
draw(ha, 1:10)
```

```{r, fig.width = 7, fig.height = 3}
ha = HeatmapAnnotation(df = df, points = anno_points(value), boxplot = anno_boxplot(t(mat)),
    annotation_height = unit.c(unit(1, "npc") - unit(4, "cm"), unit(2, "cm"), unit(2, "cm")))
draw(ha, 1:10)
```

With the annotation, you can assign in to the heatmap either by `top_annotation` or `bottom_annotation`.
Also you can control the size of total column annotations by `top_annotation_height` and `bottom_annotation_height`.

```{r}
ha = HeatmapAnnotation(df = df, points = anno_points(value))
ha_boxplot = HeatmapAnnotation(boxplot = anno_boxplot(t(mat)))
Heatmap(mat, name = "foo", top_annotation = ha, bottom_annotation = ha_boxplot, 
    bottom_annotation_height = unit(2, "cm"))
```

The `HeatmapAnnotation` is also used for construction of row annotations which we will introduce in later sections.

## A list of heatmaps

You can arrange more than one heatmaps which are placed columns by columns. Actually, one single
heatmap is just a special case of the heatmap list of length one.

`Heatmap()` is actually a class constructor function for a single heatmap. If more than one heatmaps
are to be combined, users can append one heatmap to the other by `+` operator.

```{r, fig.width = 10}
mat = matrix(rnorm(80, 2), 8, 10)
mat = rbind(mat, matrix(rnorm(40, -2), 4, 10))
rownames(mat) = paste0("R", 1:12)
colnames(mat) = paste0("C", 1:10)

ht1 = Heatmap(mat, name = "ht1")
ht2 = Heatmap(mat, name = "ht2")
class(ht1)
class(ht2)

ht1 + ht2
```

Under default mode, dendrograms from the second heatmap will be removed and row orders will be same as the first one.

The returned value of addition of two heatmaps is a `HeatmapList` object. Directly call `ht_list` object
will call `draw()` method with default settings. With explictly calling `draw()` method, you can have more control
on the legend and titles.

```{r}
ht_list = ht1 + ht2
class(ht_list)
```

You can also append any number of heatmaps to the heatmap list. Also you can append a heatmap list to a heatmap list.

```{r, eval = FALSE}
ht1 + ht1 + ht1
ht1 + ht_list
ht_list + ht1
ht_list + ht_list
```

### Titles

A heatmap list also has titles which are independent to the heatmap titles.

```{r, fig.width = 10}
ht1 = Heatmap(mat, name = "ht1", row_title = "Heatmap 1", column_title = "Heatmap 1")
ht2 = Heatmap(mat, name = "ht2", row_title = "Heatmap 2", column_title = "Heatmap 2")
ht_list = ht1 + ht2

draw(ht_list, row_title = "Two heatmaps, row title", row_title_gp = gpar(col = "red"),
    column_title = "Two heatmaps, column title", column_title_side = "bottom")
```

### Legends

Legends for all heatmaps and all annotations will be drawn together. The legends for heatmaps
and legends for annotations are put in independent viewports.

```{r, fig.width = 10, fig.keep = "all"}
df = data.frame(type = c(rep("a", 5), rep("b", 5)))
ha = HeatmapAnnotation(df = df, col = list(type = c("a" =  "red", "b" = "blue")))

ht1 = Heatmap(mat, name = "ht1", column_title = "Heatmap 1", top_annotation = ha)
ht2 = Heatmap(mat, name = "ht2", column_title = "Heatmap 2")
ht_list = ht1 + ht2

draw(ht_list)
draw(ht_list, heatmap_legend_side = "left", annotation_legend_side = "bottom")
draw(ht_list, show_heatmap_legend = FALSE, show_annotation_legend = FALSE)
```

You can choose to only add some of the heatmap legends by setting `show_heatmap_legend` to a logical value.

```{r, fig.width = 10}
ht1 = Heatmap(mat, name = "ht1", column_title = "Heatmap 1", top_annotation = ha)
ht2 = Heatmap(mat, name = "ht2", column_title = "Heatmap 2", show_heatmap_legend = FALSE)
ht1 + ht2
```

**mheatmap** only generate legends for heatmaps and simple annotations. Self-defined legends
can be passed by `annotation_legend_list` as a list of `grob` objects.

```{r, fig.width = 10}
ha = HeatmapAnnotation(points = anno_simple(rnorm(10), type = "p"))
ht2 = Heatmap(mat, name = "ht2", column_title = "Heatmap 2", top_annotation = ha, show_heatmap_legend = FALSE)
lgd = legendGrob(c("dots"), pch = 16)
draw(ht1 + ht2, annotation_legend_list = list(lgd))
```

### Gaps between heatmaps

The gaps between heatmaps can be set by `gap` argument either by a `unit` object.

```{r, fig.width = 10, fig.keep = "all"}
draw(ht_list, gap = unit(1, "cm"))
draw(ht_list + ht_list, gap = unit(c(3, 6, 9, 0), "mm"))
```

### Size of heatmaps

The width for some (not all) heatmaps can be set to a fixed width.

```{r, fig.width = 10, fig.keep = "all"}
ht1 = Heatmap(mat, name = "ht1", column_title = "Heatmap 1")
ht2 = Heatmap(mat, name = "ht2", column_title = "Heatmap 2", width = unit(5, "cm"))
ht1 + ht2
```

### Auto adjustment

There are some automatic adjustment if more than one heatmaps are plotted. There should be a main heatmap
which by default is the first one. Some settings from the second heatmap will be modified to the settings
in the first heatmap. The adjustment are:

- row clusters from the second heatmap are removed.
- row titles from the second heatmap are removed.
- if the main heatmap is splitted by rows, all remaining heatmaps will also be splitted by same levels as the first one.

The main heatmap can be specified by `main_heatmap` argument. The value can be a numeric index or the name of the heatmap
(of course, you need to set the heatmap name when you create the `Heatmap` object).

```{r, fig.width = 10, fig.keep = "all"}
ht1 = Heatmap(mat, name = "ht1", column_title = "Heatmap 1", km = 2)
ht2 = Heatmap(mat, name = "ht2", column_title = "Heatmap 2")
ht1 + ht2

draw(ht2 + ht1)
draw(ht2 + ht1, main_heatmap = "ht1")
```

## Heatmap list with row annotations

### Row annotations

Row annotation is also defined by the `HeatmapAnnotation` class, but with specifying
`which` to `row`.

```{r, fig.width = 1, fig.height = 7}
df = data.frame(type = c(rep("a", 6), rep("b", 6)))
ha = HeatmapAnnotation(df = df, which = "row", width = unit(1, "cm"))
draw(ha, 1:12)
```

### Mix heatmaps and row annotations

Essentially, row annotations and column annotations are identical graphics, but in applications,
there is some difference. In **mheatmap** package, row annotations have the same place as the heatmap
while column annotations are just like accessary components of heatmaps. For row annotations, similar
as heatmaps, you can append the row annotations to heatmap or heatmap list or even row annotation object itself.

```{r, fig.width = 9}
ht1 = Heatmap(mat, name = "ht1")
ht1 + ha + ht1
```

Also complex row annotations can be added.

```{r}
ht1 = Heatmap(mat, name = "ht1", km = 2)
ha_boxplot = HeatmapAnnotation(boxplot = anno_boxplot(mat, which = "row"), 
    which = "row", width = unit(2, "cm"))
draw(ha_boxplot + ht1, row_hclust_side = "left", row_sub_title_side = "right")
```

## Access components

Each components of the heatmap/heatmap list has a name. You can go to any viewport by `seekViewport()`.
Following figure almost contains all types of components.

```{r, fig.width = 10, fig.height = 7}
ha_column1 = HeatmapAnnotation(points = anno_points(rnorm(10)))
ht1 = Heatmap(mat, name = "ht1", km = 2, row_title = "Heatmap 1", column_title = "Heatmap 1", 
    top_annotation = ha_column1)

ha_column2 = HeatmapAnnotation(df = data.frame(type = c(rep("a", 5), rep("b", 5))))
ht2 = Heatmap(mat, name = "ht2", row_title = "Heatmap 2", column_title = "Heatmap 2",
    bottom_annotation = ha_column2)

ht_list = ht1 + ht2
draw(ht_list, row_title = "Heatmap list", column_title = "Heatmap list", 
    heatmap_legend_side = "right", annotation_legend_side = "left")
```

The components that have names are:

- `global`: the viewport which contains the whole figure.
- `global_column_title`: the viewport which contains column title for the heatmap list.
- `global_row_title`: the viewport which contains row title for the heatmap list.
- `main_heatmap_list`: the viewport which contains a list of heatmaps and row annotations.
- `heatmap_@{heatmap_name}`: the viewport which contains a single heatmap
- `annotation_@{annotation_name}`: the viewport which contains an annotation either on columns or rows.
- `@{heatmap_name}_heatmap_body_@{i}`: the heatmap body.
- `@{heatmap_name}_column_title`: column title for a single heatmap.
- `@{heatmap_name}_row_title_@{i}`: since a heatmap body may be splitted into several parts. `@{i}` is the index of the row slice.
- `@{heatmap_name}_hclust_row_@{i}`: dendrogram for ith row slice.
- `@{heatmap_name}_hclust_column`: dendrogram on columns
- `@{heatmap_name}_row_names_@{i}`: the viewport which contains row names.
- `@{heatmap_name}_column_names`: the viewport which contains column names.
- `heatmap_legend`: the viewport which contains all heatmap legends.
- `legend_@{heatmap_name}`: the viewport which contains a single heatmap legend.
- `annotation_legend`: the viewport which contains all annotation legends.
- `legend_@{annotation_name}`: the viewport which contains a single annotation legend.

```{r, fig.width = 10, fig.height = 7}
ht_list

seekViewport("annotation_points")
grid.text("points", unit(0, "npc") - unit(2, "mm"), 0.5, default.units = "npc", just = "right")

seekViewport("ht1_heatmap_body_2")
grid.text("outlier", 1.5/10, 2.5/4, default.units = "npc")

seekViewport("annotation_type")
grid.text("type", unit(1, "npc") + unit(2, "mm"), 0.5, default.units = "npc", just = "left")
```

## Real application

Data frame is an ideal data structure to store different subjects of information 
in which each row in the data frame focuses on the same element.
Then, each subject can be visualized as a single heatmap and putting all subjects 
together can give you a full view of your data.

### Gene expression

In gene expression matrix, rows correspond to genes. More information about genes can be attached after the expression
heatmap such as gene length and type of genes.

```{r, fig.width = 10, fig.height = 8}
expr = readRDS(paste0(system.file(package = "mheatmap"), "/extdata/gene_expression.rds"))
mat = as.matrix(expr[, grep("cell", colnames(expr))])

type = gsub("s\\d+_", "", colnames(mat))
ha = HeatmapAnnotation(df = data.frame(type = type))

Heatmap(mat, name = "expression", km = 5, top_annotation = ha, 
    top_annotation_height = unit(4, "mm"), show_row_names = FALSE, 
    show_column_names = FALSE) +
Heatmap(expr$length, name = "length", col = colorRamp2(c(0, 100000), c("white", "orange")),
    width = unit(5, "mm")) +
Heatmap(expr$type, name = "type", width = unit(5, "mm")) +
Heatmap(expr$chr, name = "chr", col = rand_color(length(unique(expr$chr))), 
    width = unit(5, "mm"))
```

### Visialize genomic regions

Genomic regions can have more corresponded information. E.g. for a list of differentially methylated regions (DMRs), 
we can add an expression matrix in which genes are the closest to corresponding DMR, also how DMRs overlap to 
different genomic features can be added as heatmaps as well.

In following example, there are heatmaps for methylation, expression of associated genes, correlation significance (-log10 transformed)
between methylation and expression for each DMR and the associated gene, how DMRs annotated to gene regions, and how 
DMRs annotated to enhancers. From the figure below, it is very obvious to see the enhancers are enriched in low-methylated DMRs.

```{r, fig.width = 8, fig.height = 12}
gr = readRDS(paste0(system.file(package = "mheatmap"), "/extdata/gr.rds"))

ha1 = HeatmapAnnotation(df = data.frame(type = c(rep("control", 7), rep("experiment", 5))))
ha2 = HeatmapAnnotation(df = data.frame(type = c(rep("control", 7), rep("experiment", 5))), 
    show_legend = FALSE)

ht_list = Heatmap(gr[, 1:12], name = "methylation", col = colorRamp2(c(0, 0.5, 1), c("blue", "white", "red")),
    top_annotation = ha1, top_annotation_height = unit(4, "mm"), show_row_names = FALSE,
    show_column_names = FALSE, split = gr$direction, column_title = "DMR methylation") +
Heatmap(gr[, 13:24], name = "expression", col = colorRamp2(c(-2, 0, 2), c("green", "white", "red")),
    top_annotation = ha2, top_annotation_height = unit(4, "mm"), show_row_names = FALSE,
    show_column_names = FALSE, cluster_columns = FALSE, cluster_rows = FALSE, 
    column_title = "target expression") + 
Heatmap(gr$cor_p, name = "-log10(pvalue)", col = colorRamp2(c(1, 4), c("white", "red")), width = unit(5, "mm")) +
Heatmap(gr$annotation, name = "annotation", width = unit(5, "mm")) +
Heatmap(gr[, 28:29], name = "enhancer", col = colorRamp2(c(0, 1), c("white", "orange")), 
    cluster_columns = FALSE, show_row_names = FALSE, width = unit(1, "cm"), cluster_rows = FALSE,
    column_names_max_height = grobWidth(textGrob("strong_enhancer", gp = gpar(fontsize = 12))),
    column_title = "enhancer")

draw(ht_list, column_title = qq("negative correlation between DMR methylation and target expression\n@{nrow(gr)} interactions"))
```



